<html>
 <head></head>
 <body>
  <h2 style="text-align: center;">Overriding instance methods</h2>
  <p>Java provides an ability to declare a method in a subclass with the same name as a method in the superclass. It's known as <b>method overriding</b>. The benefit of overriding is that a subclass can give its own specific implementation of a superclass method.</p>
  <p><b>Overriding methods</b> in subclasses allows a class to inherit from a superclass whose behavior is <b>"close enough" </b>and then to change this behavior as the subclass needed.<br></p>
  <p>Instance methods can be overridden if they are inherited by the subclass. The overriding method must have the same name, parameters (number and type of parameters), and the return type (or a subclass of the type) as the overridden method.<br></p>
  <p><b>Example. </b>Here<b> </b>is an examples of overriding.</p>
  <pre><code class="language-java">class Mammal {

&nbsp; &nbsp; public String sayHello() {
&nbsp; &nbsp; &nbsp; &nbsp; return "ohlllalalalalalaoaoaoa";
&nbsp; &nbsp; }
}

class Cat extends Mammal {

&nbsp; &nbsp; @Override
&nbsp; &nbsp; public String sayHello() {
&nbsp; &nbsp; &nbsp; &nbsp; return "meow";
&nbsp; &nbsp; }
}

class Human extends Mammal {

&nbsp; &nbsp; @Override
&nbsp; &nbsp; public String sayHello() {
&nbsp; &nbsp; &nbsp; &nbsp; return "hello";
&nbsp; &nbsp; }
}</code></pre>
  <p>The hierarchy includes three classes: <code>Mammal</code>, <code>Cat</code> and <code>Human</code>. The class <code>Mammal</code> has the method <code>sayHello</code>. Each subclass overrides the method. The <code>@Override</code> annotation indicates the method is overridden. It is optional but helpful.</p>
  <p>Let's create instances and invoke the method.</p>
  <pre><code class="language-java">Mammal mammal = new Mammal();
System.out.println(mammal.sayHello()); // it prints "ohlllalalalalalaoaoaoa"

Cat cat = new Cat();
System.out.println(cat.sayHello()); // it prints "meow"

Human human = new Human();
System.out.println(human.sayHello()); // it prints "hello"</code></pre>
  <p>As you can see, each subclass has its own implementation of the method <code>sayHello</code>.</p>
  <p><b>Note:</b> you can invoke the base class method in the overridden method using the keyword <code>super</code>.</p>
  <h2 style="text-align: center;">Rules for overriding methods</h2>
  <p>There are several rules for methods of subclasses which should override methods of a superclass:</p>
  <ul>
   <li>the method must have the same name as in the superclass;</li>
   <li>the arguments should be exactly the same as in the superclass method;</li>
   <li>the return type should be the same or a subtype of the return type declared in the method of the superclass;</li>
   <li>the access level must be the same or more open than the overridden method's access level;</li>
   <li><b></b>a private method cannot be overridden<b></b> because it's not inherited by subclasses;</li>
   <li>if the superclass and its subclass are in the same package, then package-private methods can be overridden;</li>
   <li><b></b>static methods cannot be overridden<b></b>.</li>
  </ul>
  <p>To verify these rules, here is a special annotation <b>@Override</b>. It allows you to know whether a method will be actually <b>overridden</b> or no. If for some reason, the compiler decides the method cannot be overridden, it will generate an error. But, remember, the annotation is not required, it's only for convenience.</p>
  <h2 style="text-align: center;">Forbidding overriding</h2>
  <p>If you'd like to forbid an overriding of a method, declare it with the keyword <b>final</b>.<br></p>
  <pre><code class="language-java">public final void method() {
&nbsp; &nbsp; // do something
}</code></pre>
  <p>Now, If you try to override this method in a subclass, a compile-time error happens.</p>
  <h2 style="text-align: center;">Overriding and overloading methods together</h2>
  <p>It's possible to override and overload an instance method in a subclass at the same time. Overloaded methods do not override superclass instance methods. They are new methods, unique to the subclass.<br></p>
  <p>The following example demonstrates it.</p>
  <pre><code class="language-java">class SuperClass {

&nbsp; &nbsp; public void invokeInstanceMethod() {
&nbsp; &nbsp; &nbsp; &nbsp; System.out.println("SuperClass: invokeInstanceMethod");
&nbsp; &nbsp; }
}

class SubClass extends SuperClass {

&nbsp; &nbsp; @Override
&nbsp; &nbsp; public void invokeInstanceMethod() {
&nbsp; &nbsp; &nbsp; &nbsp; System.out.println("SubClass: invokeInstanceMethod is overridden");
&nbsp; &nbsp; }
&nbsp; &nbsp; 
&nbsp; &nbsp; // @Override -- method doesn't override anything
&nbsp; &nbsp; public void invokeInstanceMethod(String s) {
&nbsp; &nbsp; &nbsp; &nbsp; System.out.println("SubClass: overloaded invokeInstanceMethod");
&nbsp; &nbsp; }
}</code></pre>
  <p>The following code creates an instance and calls both methods:</p>
  <pre><code class="language-java">SubClass clazz = new SubClass();

clazz.invokeInstanceMethod();    // SubClass: invokeInstanceMethod() is overridden
clazz.invokeInstanceMethod("s"); // SubClass: overloaded invokeInstanceMethod(String)</code></pre>
  <p>Remember, overriding and overloading are different mechanisms but you can mix them together in one class hierarchy.</p>
  <h2 style="text-align: center;">Hiding static methods</h2>
  <p>Static methods cannot be overridden. If a subclass has a static method with the same signature (name and parameters) as a static method in the superclass then the method in the subclass hides the one in the superclass. It's completely different from methods overriding.</p>
  <p>You will get a compile-time error if a subclass has a static method with the same signature as an instance method in the superclass or vice versa. But if the methods have the same name but different parameters there are no problems.</p>
 </body>
</html>